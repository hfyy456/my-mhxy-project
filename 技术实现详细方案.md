# æŠ€æœ¯å®ç°è¯¦ç»†æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
- [æ€§èƒ½ä¼˜åŒ–è¯¦ç»†å®ç°](#æ€§èƒ½ä¼˜åŒ–è¯¦ç»†å®ç°)
- [TypeScriptè¿ç§»æŒ‡å—](#typescriptè¿ç§»æŒ‡å—)
- [æµ‹è¯•æ¡†æ¶æ­å»º](#æµ‹è¯•æ¡†æ¶æ­å»º)
- [CI/CDæµæ°´çº¿](#cicdæµæ°´çº¿)
- [ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ](#ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ)

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è¯¦ç»†å®ç°

### 1. PixiJSé«˜çº§ä¼˜åŒ–æŠ€æœ¯

#### çº¹ç†å›¾é›†ä¼˜åŒ–
```javascript
// çº¹ç†å›¾é›†ç®¡ç†å™¨
class TextureAtlasManager {
  constructor() {
    this.atlases = new Map();
    this.textureCache = new Map();
  }
  
  async loadAtlas(atlasName, jsonPath, imagePath) {
    const atlasData = await fetch(jsonPath).then(r => r.json());
    const baseTexture = await PIXI.BaseTexture.from(imagePath);
    
    const atlas = {};
    for (const frameName in atlasData.frames) {
      const frameData = atlasData.frames[frameName];
      const rectangle = new PIXI.Rectangle(
        frameData.frame.x,
        frameData.frame.y, 
        frameData.frame.w,
        frameData.frame.h
      );
      
      atlas[frameName] = new PIXI.Texture(baseTexture, rectangle);
    }
    
    this.atlases.set(atlasName, atlas);
    return atlas;
  }
  
  getTexture(atlasName, textureName) {
    const cacheKey = `${atlasName}:${textureName}`;
    
    if (this.textureCache.has(cacheKey)) {
      return this.textureCache.get(cacheKey);
    }
    
    const atlas = this.atlases.get(atlasName);
    if (atlas && atlas[textureName]) {
      this.textureCache.set(cacheKey, atlas[textureName]);
      return atlas[textureName];
    }
    
    console.warn(`Texture not found: ${cacheKey}`);
    return PIXI.Texture.WHITE;
  }
}
```

#### å¯¹è±¡æ± æ¨¡å¼
```javascript
class SpritePool {
  constructor(texture, initialSize = 10) {
    this.texture = texture;
    this.pool = [];
    this.active = new Set();
    
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(new PIXI.Sprite(texture));
    }
  }
  
  acquire() {
    let sprite;
    if (this.pool.length > 0) {
      sprite = this.pool.pop();
      sprite.visible = true;
    } else {
      sprite = new PIXI.Sprite(this.texture);
    }
    
    this.active.add(sprite);
    return sprite;
  }
  
  release(sprite) {
    if (this.active.has(sprite)) {
      this.active.delete(sprite);
      sprite.visible = false;
      this.pool.push(sprite);
    }
  }
}
```

### 2. Reactç»„ä»¶ä¼˜åŒ–

#### è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
```javascript
import { FixedSizeList } from 'react-window';

const VirtualizedInventory = ({ items }) => {
  const ItemRenderer = ({ index, style }) => (
    <div style={style}>
      <SummonCard summon={items[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={120}
      overscanCount={5}
    >
      {ItemRenderer}
    </FixedSizeList>
  );
};
```

#### çŠ¶æ€æ›´æ–°ä¼˜åŒ–
```javascript
// ä½¿ç”¨immerè¿›è¡Œä¸å¯å˜çŠ¶æ€æ›´æ–°
import { produce } from 'immer';

const battleReducer = (state, action) => {
  return produce(state, draft => {
    switch (action.type) {
      case 'UNIT_TAKE_DAMAGE':
        const { unitId, damage } = action.payload;
        const unit = draft.units.find(u => u.id === unitId);
        if (unit) {
          unit.derivedAttributes.currentHp = Math.max(0, unit.derivedAttributes.currentHp - damage);
          unit.isDefeated = unit.derivedAttributes.currentHp === 0;
        }
        break;
        
      case 'APPLY_STATUS_EFFECT':
        const { targetId, statusEffect } = action.payload;
        const target = draft.units.find(u => u.id === targetId);
        if (target) {
          const existingEffect = target.statusEffects.find(
            e => e.id === statusEffect.id
          );
          
          if (existingEffect) {
            existingEffect.duration = statusEffect.duration;
            existingEffect.stacks = Math.min(
              existingEffect.stacks + 1,
              statusEffect.maxStacks || 1
            );
          } else {
            target.statusEffects.push({ ...statusEffect, stacks: 1 });
          }
        }
        break;
    }
  });
};
```

### 3. å†…å­˜ç®¡ç†ç­–ç•¥

#### æ™ºèƒ½èµ„æºåŠ è½½
```javascript
// èµ„æºåŠ è½½ç®¡ç†å™¨
class ResourceManager {
  constructor() {
    this.loadedResources = new Map();
    this.loadingPromises = new Map();
    this.memoryUsage = 0;
    this.maxMemoryUsage = 500 * 1024 * 1024; // 500MB
    this.lruCache = new Map();
  }
  
  async loadResource(url, type = 'texture') {
    // æ£€æŸ¥æ˜¯å¦å·²åœ¨åŠ è½½ä¸­
    if (this.loadingPromises.has(url)) {
      return this.loadingPromises.get(url);
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
    if (this.loadedResources.has(url)) {
      this.updateLRU(url);
      return this.loadedResources.get(url);
    }
    
    // å¼€å§‹åŠ è½½
    const loadPromise = this.doLoadResource(url, type);
    this.loadingPromises.set(url, loadPromise);
    
    try {
      const resource = await loadPromise;
      this.loadedResources.set(url, resource);
      this.updateLRU(url);
      this.updateMemoryUsage(resource);
      
      // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
      if (this.memoryUsage > this.maxMemoryUsage) {
        await this.freeOldResources();
      }
      
      return resource;
    } finally {
      this.loadingPromises.delete(url);
    }
  }
  
  async doLoadResource(url, type) {
    switch (type) {
      case 'texture':
        return PIXI.Texture.from(url);
      case 'audio':
        return this.loadAudio(url);
      case 'json':
        return fetch(url).then(r => r.json());
      default:
        throw new Error(`Unknown resource type: ${type}`);
    }
  }
  
  updateLRU(url) {
    this.lruCache.delete(url);
    this.lruCache.set(url, Date.now());
  }
  
  async freeOldResources() {
    const sortedEntries = Array.from(this.lruCache.entries())
      .sort((a, b) => a[1] - b[1]);
    
    const toRemove = sortedEntries.slice(0, Math.floor(sortedEntries.length * 0.3));
    
    for (const [url] of toRemove) {
      const resource = this.loadedResources.get(url);
      if (resource && resource.destroy) {
        resource.destroy();
      }
      
      this.loadedResources.delete(url);
      this.lruCache.delete(url);
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
    if (window.gc) {
      window.gc();
    }
  }
}
```

---

## ğŸ“ TypeScriptè¿ç§»æŒ‡å—

### 1. æ ¸å¿ƒç±»å‹å®šä¹‰
```typescript
export interface BattleUnit {
  readonly id: string;
  name: string;
  level: number;
  derivedAttributes: UnitStats;
  skills: readonly Skill[];
  statusEffects: StatusEffect[];
  isDefeated: boolean;
}

export interface UnitStats {
  readonly maxHp: number;
  currentHp: number;
  readonly maxMp: number;
  currentMp: number;
  attack: number;
  defense: number;
  speed: number;
}

export enum SkillType {
  ACTIVE = 'active',
  PASSIVE = 'passive',
  ULTIMATE = 'ultimate'
}
```

### 2. ç»„ä»¶ç±»å‹åŒ–
```typescript
interface BattleUnitCardProps {
  unit: BattleUnit;
  isSelected: boolean;
  onSelect?: (unit: BattleUnit) => void;
}

export const BattleUnitCard: React.FC<BattleUnitCardProps> = ({
  unit,
  isSelected,
  onSelect
}) => {
  const handleClick = useCallback(() => {
    if (onSelect) {
      onSelect(unit);
    }
  }, [unit, onSelect]);

  return (
    <div className={`battle-unit-card ${isSelected ? 'selected' : ''}`}>
      <h3>{unit.name}</h3>
      <div>Lv.{unit.level}</div>
    </div>
  );
};
```

---

## ğŸ§ª æµ‹è¯•æ¡†æ¶æ­å»º

### 1. Jesté…ç½®
```javascript
module.exports = {
  testEnvironment: 'jsdom',
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  }
};
```

### 2. ç»„ä»¶æµ‹è¯•
```typescript
describe('BattleField Component', () => {
  it('renders units correctly', () => {
    render(<BattleField />);
    expect(screen.getByTestId('battle-field')).toBeInTheDocument();
  });
});
```

---

## ğŸ”„ CI/CDæµæ°´çº¿

### GitHub Actionsé…ç½®
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm run test:coverage
```

---

## ğŸ“Š ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ

### æ€§èƒ½ç›‘æ§
```typescript
class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  
  recordMetric(name: string, value: number, category: string) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      category
    });
  }
  
  generateReport() {
    return {
      avgFPS: this.calculateAverage('fps'),
      avgMemory: this.calculateAverage('memory'),
      metrics: this.metrics
    };
  }
}
```

### é”™è¯¯å¤„ç†
```typescript
class ErrorHandler {
  handleError(errorInfo: ErrorInfo) {
    console.error('Game Error:', errorInfo);
    this.sendToMonitoring(errorInfo);
  }
  
  private async sendToMonitoring(errorInfo: ErrorInfo) {
    if (process.env.NODE_ENV === 'production') {
      await fetch('/api/errors', {
        method: 'POST',
        body: JSON.stringify(errorInfo)
      });
    }
  }
}
```

---

*æ–‡æ¡£æ›´æ–°æ—¥æœŸ: 2024å¹´1æœˆ*  
*ç»´æŠ¤è€…: Sirius* 