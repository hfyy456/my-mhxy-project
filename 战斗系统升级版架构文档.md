# 战斗系统升级版架构文档

## 1. 概述

本文档详细描述了对梦幻西游单机版战斗系统进行现代化升级后的架构。新架构融合了**面向对象编程 (OOP)**、**层次状态机 (HSM)** 和**纯函数 (Pure Functions)** 的优点，旨在最大化代码的可读性、可维护性和可扩展性。

## 2. 核心设计理念

新架构基于以下三大核心理念：

1.  **OOP 封装状态与行为**: 使用类（Class）来封装属于同一个实体的数据（状态）和操作这些数据的方法（行为）。在战斗系统中，`BattleUnit` 类就是这一理念的核心体现，它代表了战场上的每一个单位。

2.  **HSM 驱动流程**: 使用层次状态机（Hierarchical State Machine）来管理复杂的战斗流程。状态机负责"何时"做事（例如，现在是"玩家行动阶段"还是"战斗结算阶段"），但不关心"如何"做的具体细节。

3.  **Pure Functions 处理核心计算**: 使用纯函数来执行无副作用的、可预测的计算。例如，伤害计算、技能效果判定等。这些函数接收输入，返回输出，不改变任何外部状态，使得核心逻辑的测试和验证变得极其简单。

### 交互模型

三者之间的关系可以概括为：

> **层次状态机（HSM）** 在正确的 **时间点**，调用 **`BattleUnit` 对象** 的 **方法**，该方法内部则使用 **纯函数** 来进行复杂计算，并最终 **更新自身的状态**。

```mermaid
graph TD
    subgraph "控制层 (Control Layer)"
        HSM[层次状态机<br>(BattleStateMachine)]
    end

    subgraph "模型层 (Model Layer)"
        Unit[BattleUnit 对象实例]
    end

    subgraph "逻辑层 (Logic Layer)"
        PureFunc[纯函数<br>(damageCalculation, skillSystem)]
    end

    HSM -- "触发行动<br>(doAttack, useSkill)" --> Unit
    Unit -- "调用方法<br>(takeDamage, applyBuff)" --> Unit
    Unit -- "请求计算<br>(calculateDamage)" --> PureFunc
    PureFunc -- "返回结果" --> Unit
```

## 3. 架构组件详解

### 3.1. 模型层：`BattleUnit` 类

**文件**: `src/features/battle/models/BattleUnit.js`

这是本次升级的核心。`BattleUnit` 类是一个战斗单位的完整抽象。

-   **属性 (State)**:
    -   `id`, `name`, `level`
    -   `stats`: 包含 `hp`, `mp`, `attack`, `defense`, `speed` 等所有战斗数值。
    -   `statusEffects`: 存储当前单位身上的所有 Buff 和 Debuff。
    -   `isDefeated`: 单位是否被击败。

-   **方法 (Behavior)**:
    -   `constructor(...)`: 初始化一个战斗单位实例。
    -   `takeDamage(damage, source)`: 单位承受伤害。它会调用 `damageCalculation.js` 中的纯函数计算护盾、减伤等，然后更新自己的 `stats.currentHp`。
    -   `applyHealing(healing)`: 单位接受治疗。
    -   `applyBuff(buffId, sourceUnitId)`: 为单位添加一个状态效果。
    -   `removeBuff(buffId)`: 移除单位的某个状态效果。
    -   `canAct()`: 判断单位当前是否可以行动（例如，是否被眩晕）。

**优点**:
-   **封装**: 将战斗单位相关的所有逻辑都内聚到同一个类中，外部代码无需关心其内部实现。
-   **单一职责**: `BattleUnit` 只负责管理自身的状态和行为，不关心战斗流程。
-   **代码清晰**: 相比于之前操作纯 JavaScript 对象，`target.takeDamage(100)` 远比 `target.hp -= 100` 要清晰，并且前者可以处理更复杂的逻辑（如护盾、免死等）。

### 3.2. 控制层：`BattleStateMachine`

**文件**: `src/features/battle/state/BattleStateMachine.js`

状态机作为战斗的"大脑"或"指挥官"，其职责被进一步提纯。

-   **职责**:
    -   管理战斗的核心阶段：`INITIALIZATION`, `ACTIVE` (包含 `ROUND_START`, `PREPARATION`, `EXECUTION`, `RESOLUTION`), `END`。
    -   根据单位速度决定行动顺序。
    -   在正确的时机，调用 `BattleUnit` 实例的相应方法。

-   **升级后的变化**:
    -   状态机 **不再直接修改** 单位的属性。
    -   旧代码: `target.stats.currentHp -= damage;`
    -   新代码: `target.takeDamage(damageResult.finalDamage, caster);`
    -   状态机现在更像一个指挥官，它下达命令（"A攻击B"），而具体执行和状态变化由单位自己负责。

**优点**:
-   **职责分离**: 状态机的逻辑变得更纯粹，只关心流程控制。
-   **可读性增强**: 状态机中的代码读起来更像自然语言描述的战斗流程。

### 3.3. 逻辑层：纯函数模块

**文件**: `src/features/battle/logic/*.js`

这些文件（如 `damageCalculation.js`, `skillSystem.js`）的职责和结构保持不变，因为它们已经遵循了良好的设计实践。

-   **`damageCalculation.js`**:
    -   `calculatePhysicalDamage(...)`: 根据攻击、防御、暴击等参数计算最终物理伤害。
    -   `calculateMagicalDamage(...)`: 计算最终法术伤害。
    -   这些函数是无状态的，给定相同的输入，永远返回相同的输出。

-   **`skillSystem.js`**:
    -   `getValidTargetsForSkill(...)`: 根据技能配置和战场情况，返回所有有效的目标。
    -   `getSkillAffectedArea(...)`: 计算技能的影响范围。

**优点**:
-   **可测试性**: 纯函数非常容易进行单元测试。
-   **可预测性**: 其行为不依赖于外部状态，易于推理和调试。
-   **可复用性**: 可以在系统的任何地方安全地调用，而不用担心副作用。

## 4. 总结

通过本次升级，战斗系统形成了一个稳定、清晰、可扩展的黄金三角架构：

-   **`BattleUnit` (OOP)** 负责"是什么"（数据和能力）。
-   **`BattleStateMachine` (HSM)** 负责"做什么"（流程和时机）。
-   **Pure Functions** 负责"怎么算"（核心算法和规则）。

这种架构不仅提升了当前代码的质量，也为未来添加更复杂的功能（如天气系统、连携攻击、更复杂的AI策略）打下了坚实的基础。 